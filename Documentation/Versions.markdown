Версионирование документов и поведение клиента
================================

Ресурсы: файлы, созданные пользователем в процессе работы с системой. На текущий момент - рисование и звук. 
Ресурс существует в контексте контейнера. 
Контнейнером в текущей реализации может быть: 
        - страница файла документа   
        - непосредственно проект резолюции/проект документа. ( документ ) 

Контейнер - страница файла, задается след. образом: 
        parent = { document: doc_id, file: file_id , pageNum: pageNum } 
Контейнер - документ задается при помощи: 
        parent = { document: id } 

Типы данных 
id - строка, pageNum - целое неотрицательное. 

Ресурс обладает уникальным строковым представлением (hash). Изменение этого представления означает изменение самого файла. Хеши файлов, как минимум, уникальны внутри контейнера.


Создание, удаление, изменение ресурса происходит POST мультипартом на известный url. Мультипарт из двух частей: управляющий json и контент ресурса. В случае удаление ресурса - контент не передается. В управляющем json указывается: версия документа, контейнер, id и version ресурса 
        
Создание ресурса.Запрос. 
	json = { 
        docVersion: doc_version, 
        parent: { 
                document: doc_id, 
                file: file_id, 
                pageNum: pageNum 
                }, 
        audio: null
	} 
file = filecontent 

Создание ресурса.Ответ. 
успех(200): 
	{ 
        docVersion: new_doc_version, 
        parent: { 
                document: doc_id, 
                file: file_id, 
                pageNum: pageNum 
        }, 
        audio: file_hash
	} 
неудача 
        404 - например при попытке записи в несуществующий контенейнер 
        500 - например при попытке создание второго рисования к странице. (конфликт) 

конкретное сообщение об ошибке зависит от ситуации и описано в протоколе ошибок: 
3. При конфликтах записи на сервер (к этому относится несоответствие
версий закачиваемых файлов, версий документов, документ только на
чтение и тп)

Формат ошибки.
-------------------------------
сервер должен отвечать с кодом 500:
	{
    	"error":
        {
        	"code":numeric_error_code,
         	"message":"human readable message"
        }
	}


Изменение ресурса.Запрос. 
	json = { 
        docVersion: doc_version, 
        parent: { 
                document: doc_id, 
                file: file_id, 
                pageNum: pageNum 
                }, 
        audio: file_hash
	} 
file = filecontent 
Изменение ресурса. Ответ 
успех(200): 
	{ 
        docVersion: new_doc_version, 
        parent: { 
                document: doc_id, 
                file: file_id, 
                pageNum: pageNum 
        }, 
        audio: file_hash
	} 
неудача 
        404 - например при попытке записи в несуществующий контенейнер, при попытке изменения несуществующего ресурса 
        500 - например при несовпадений версии ресурса или документа 
                
Удаление ресурса.Запрос 
	json = { 
        docVersion: doc_version, 
        parent: { 
                document: doc_id, 
                file: file_id, 
                pageNum: pageNum 
                }, 
                audio: file_hash
		} 
file не передается. 
Удаление ресурса.Ответ 
успех(200): 
	{ 
        docVersion: new_doc_version, 
        parent: { 
                document: doc_id, 
                file: file_id, 
                pageNum: pageNum 
        }, 
        audio: null 
	} 
неудача 
        404 - например при попытке записи в несуществующий контенейнер, при попытке изменения несуществующего ресурса 
        500 - например при несовпадений версии 


контейнер-документ: содержит в корне json-поле resources: 
	{ 
        drawing: file_hash
        audio: file_hash
	} 
при полном отсутствии ресурсов в контейнере поле resources не передается 

контейнеры-страницы. располагаются внтутри файла. представлены массивом resources. каждому контейнеру соотвествует элемент массива. 
	{ 
        pagenum: pagenum, 
        drawing: file_hash
	} 
при полном отсутствии ресурсов к странице - отсутствует соответсвующий элемент с этим pageNum 

при отсутсвии одного из ресурсов в контейнере - соответсвующее поле ( drawing или audio ) не передаецтся 


Примеры: 
Т.о. в общем виде это выглядит так: 
	{ 
        id: docid, 
        docVersion: docVersion, 
        ... 
        document:{ 
                ... 
                files: [ 
                        { 
                                id: file_id, 
                                pageCount: pageCount, 
                                ... 
                                resources: [ 
                                        { 
                                                pageNum: pageNum, 
                                                drawing: file_hash
                                        }, 
                                        { 
                                                pageNum: pageNum, 
                                                drawing: file_hash
                                        }, 
                                        .... 
                                ] 
                        }, 
                        
                ] 
        } 
        ... 
        resources: { 
                drawing: file_hash
                audio: file_hash
        } 
	} 

Отсутcвие ресурсов к документу 
	{ 
        id: docid, 
        docVersion: docVersion, 
        ... 
	} 

Отсутствие рисования к документу: 
	{ 
        id: docid, 
        docVersion: docVersion, 
        ... 
        resources: { 
                audio: file_hash
        } 
	} 

Отсутствие рисования к странице: 
	{ 
        id: docid, 
        docVersion: docVersion, 
        ... 
        document:{ 
                ... 
                files: [ 
                        { 
                                ... 
                                resources: [ 
                                        { 
                                                pageNum: pageNum, 
                                                audio: file_hash
                                        }, 
                                        .... 
                                ] 
                        }, 
                        
                ] 
        } 
        ... 
	} 



при получении документа смотрим на id документа. 
 - на клиенте нет документа с этим id -> документ ранее не загружался -> скачиваем документ и контент. финиш. 

 - версия docVersion на клиенте отличается от полученной: 

1. Статус документа: 
клиент переводит документ в серверный статус. 

2. Текстовые поля документа: 
дата исполнения, текст резолюции, исполнители, проиритет и т.п. 
С целью упрощения работы, для текстовых полей вводится "версия всех редактируемых текстовых полей": contentVersion 
Клиент смотрит на contentVersion и если она не совпадает с серверной - клиент обновляет свои поля. 

Принято решение, что изменение contentVersion метит контейнер-документ как измененный. В соответсвии с этим все локальные измения ресурсов д.б. отменены, контент(при необходимости) перекачан. Т.е. на вопрос: "если изменился документ (скажем, изменили текст резолюции) то все аудио убиваются?" - ответ: "Если есть локальные изменения, то они убиваются" 

Фактически можно рассматривать текстовые поля резолюции как прототип будущих текстовых комментов к файлам документа. 


3.Ресурсы: 

Выбрана стратегия слияния: слияние на уровне контейнера 
если при загрузке документа с сервера обнаружено, что содержимое контейнера изменилось, то локальный изменения аннулируются и контейнер приводится в соответствие серверу. 

Пример реализации схемы на клиенты 
         строим хэшмэп всех ресурсов серверного документа: 
                ключ: parent , type ,id 
                значение: значение соотвествующего поля (хэш) 
        и аналогичный клиенский hashmap 
        
        step1. проходим по серверной коллекции 
                case1. - ключ отсутствует в клиентской: скачиваем контент на клиента, метим контейнер как измененный, выкидываем элемент из коллекции 
                case2. - ключ есть на клиенской, версии не совпадают: перекачиваем контент, ставим актуальную версию, метим контейнер как измененный, выкидываем элемент из коллекции 
                case3. - ключ есть на клиенской, версии совпадают,нет локальных изменений: nothing todo, выкидываем элемент из коллекции 
                case4 -  ключ есть на клиенской, версии совпадают,есть локальные изменения: метим элемент, оставляем в коллекции 
                
        step2. проходим по сильно поредевшей клиентской коллекции, выкидываем удаленные на сервере элементы: 
                элемент версифицирован, нет отметки с шага step1.case4: метим контейнер как измененный, удаляем контент 
        
        step3. принятие решение об судьбе оставшихся элементов: 
                есть отметка step1.case4: ( изменен локально, есть на сервере ) 
                        контейнер изменен: перекачиваем ресурс ( затираем локальные изменения ) 
                        контейнер не изменен: аплодим ресурс ( update ) 
                нет отметки step1.case4: ( изменен локально и нет на сервере - новый ресурс ) 
                        контейнер изменен: удаляем ресурс 
                        контейнер не изменен: аплодим ресурс ( create ) 
        финиш. 

В случае если документ пришел в статусе "readonly" ( editable=false ) - на шаге step3 вместо update - перекачиваем ресурс, вместо create - удаляем.